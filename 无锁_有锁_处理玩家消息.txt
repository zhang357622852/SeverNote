
1.问题：同一个玩家发出多个请求包，到了服务端可能被不同的线程同时处理（并行处理），这里就出现了线程同步问题（请求B，是依照前一个请求A的结果做处理的，如果请求B和请求A不在同一个线程上，到时就会出现数据处理错误的问题）

2.解决方案：
	1.每一个玩家自带一个动作锁，当请求包上来后，立即将玩家个人锁锁住，等处理完这个请求后再解锁，处理第二个请求，使玩家个人行为从并行状态改成串行状态，保证了处理逻辑的正确性。
	但从本质而言，不一定所有的请求都需要同步，多余的锁会消耗不必要的资源。
	
	2.每一个玩家，固定指派到指定线程，多个请求都放在同一个消息队列里。这些消息在固定的线程里按顺序执行。从而达到无锁处理玩家个人请求。
	实现这一目标，典型的解决方案可以采用Actor消息模式，每一个玩家都设计为一个Actor，将对玩家的请求都发到该玩家的邮箱里


	3.关于这个问题，我们只要能将角色请求通过某种关系，映射到给固定的线程执行即可。为此，我们可以初始化若干线程池，对于计算型的任务，可以将线程池的大小N设为略多于处理器的数量。但需要注意的是，我们不是初始化一个线程池，其大小为N。而是初始化N个线程池，每一个线程池只有一个线程！！将这些线程池放到一个数组，这样就可以通过角色号直接映射到指定线程了。
	Netty框架的线程模型也是采用这种机制，一个连接在整个生命周期都绑定在一个指定的线程。